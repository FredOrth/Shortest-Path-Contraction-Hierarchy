/*
 * This source file was generated by the Gradle 'init' task
 */
package Testing;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.ClassOrderer.ClassName;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.TestInstance;
import org.junit.jupiter.api.Test;

import Project.Graphs.EdgeWeightedGraph;
import Project.Graphs.GraphBuilder;
import Project.Graphs.GraphBuilderResult;
import Project.Dijkstra.BidirectionalDijkstra;
import Project.Dijkstra.DijkstraUndirectedSP;
import Project.Graphs.Edge;

import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.junit.jupiter.api.Assertions.fail;
import static org.junit.jupiter.api.Assertions.assertEquals;

import java.io.*;
import java.net.URL;

class SmallGraphTesting {
    private static GraphBuilderResult smallGraph;


    @BeforeAll
    public static void graphInit() throws FileNotFoundException {
        
        InputStream inputStream = SmallGraphTesting.class.getResourceAsStream("/Small_graph_for_test.graph");
        if (inputStream == null) {
            throw new FileNotFoundException("Resource 'Small_graph_for_test.graph' not found in classpath");
        }
        smallGraph = GraphBuilder.buildGraphFromInputStream(inputStream);

    }


    /* 
     * This tests checks whether the small graph from Small_graph_for_test
     * is generated correctly with:
     * 20 Vertexes and their longitude + latitude
     */
    @Test
    public void checkSmallGraphVertexes(){
        
       

        EdgeWeightedGraph graph = smallGraph.getGraph();

        // Check correct number of vertexes
        assertEquals(graph.V(),20);

        /* 
        Check whether vertex 1000 is not null and has the right longitude/latitude
        Note that for four of the following assertions we use the delta to define the the maximum difference/deviation allowed.
            */
        float[] vertex1000Coords = smallGraph.getVertexMap().get(1000L);
        assertNotNull(vertex1000Coords, "Vertex 1000 should exist in the vertex map");
        assertEquals(1.0, vertex1000Coords[0], 0.01, "Longitude of vertex 1000 should be 1.0");
        assertEquals(2.0, vertex1000Coords[1], 0.01, "Latitude of vertex 1000 should be 2.0");

        // Check whether vertex 2000 is not null and has the right longitude/latitude
        // Note we use the delta to define the the maximum difference/deviation allowed.
        float[] vertex1018Coords = smallGraph.getVertexMap().get(1018L);
        assertNotNull(vertex1018Coords, "Vertex 1000 should exist in the vertex map");
        assertEquals(19.1, vertex1018Coords[0], 0.01, "Longitude of vertex 1018 should be 19.1");
        assertEquals(20.0, vertex1018Coords[1], 0.01, "Latitude of vertex 1018 should be 20.0");

        
    }

    /* 
     * This tests checks whether the small graph from Small_graph_for_test
     * is generated correctly with:
     * 25 edges and their weights.
     * We furthermore check 4 edges if they're instantiated correctly
     */
    @Test
    public void checkSmallGraphEdges(){
        
        EdgeWeightedGraph graph = smallGraph.getGraph();

        // Check correct number of edges
        assertEquals(graph.E(),25);

        // Check degree for arbitrarily chosen vertex
        assertEquals(graph.degree(5),3);


        // Check for edge between vertex 1000 (id 0) and vertex 1001 (id 1) with weight 1.0
        boolean edge1000_1001_Found = false;
        for (Edge e : graph.edges()) {
            int v = e.either();
            int w = e.other(v);
            if ((v == 0 && w == 1 && e.weight() == 1.0) || (v == 1 && w == 0 && e.weight() == 1.0)) {
                edge1000_1001_Found = true;
                break;
            }
        }
        assertTrue(edge1000_1001_Found, "Edge between vertex 1000 and vertex 1001 with weight 1 should exist");

        // Check for edge between vertex 1000 (id 0) and vertex 1002 (id 2) with weight 2.0
        boolean edge1000_1002_Found = false;
        for (Edge e : graph.edges()) {
            int v = e.either();
            int w = e.other(v);
            if ((v == 0 && w == 2 && e.weight() == 2.0) || (v == 2 && w == 0 && e.weight() == 2.0)) {
                edge1000_1002_Found = true;
                break;
            }
        }
        assertTrue(edge1000_1002_Found, "Edge between vertex 1000 and vertex 1002 with weight 2 should exist");

        // Check for edge between vertex 1001 (id 1) and vertex 1003 (id 3) with weight 1.0
        boolean edge1001_1003_Found = false;
        for (Edge e : graph.edges()) {
            int v = e.either();
            int w = e.other(v);
            if ((v == 1 && w == 3 && e.weight() == 1.0) || (v == 3 && w == 1 && e.weight() == 1.0)) {
                edge1001_1003_Found = true;
                break;
            }
        }
        assertTrue(edge1001_1003_Found, "Edge between vertex 1001 and vertex 1003 with weight 1 should exist");

        // Check for edge between vertex 1003 (id 3) and vertex 1005 (id 5) with weight 2.0
        boolean edge1003_1005_Found = false;
        for (Edge e : graph.edges()) {
            int v = e.either();
            int w = e.other(v);
            if ((v == 3 && w == 5 && e.weight() == 2.0) || (v == 5 && w == 3 && e.weight() == 2.0)) {
                edge1003_1005_Found = true;
                break;
            }
        }
        assertTrue(edge1003_1005_Found, "Edge between vertex 1003 and vertex 1005 with weight 2 should exist");
    }

    @Test
    public void testEarlyStoppingCriteria(){
        EdgeWeightedGraph graph = smallGraph.getGraph();
        DijkstraUndirectedSP dijkstrastoppingPoint = new DijkstraUndirectedSP(graph);
        double distance = dijkstrastoppingPoint.computeShortestPath(0, 10);
        assertEquals(9.0, distance);

    }

    @Test
    public void testBidirectionalDijkstra(){
        EdgeWeightedGraph graph = smallGraph.getGraph();
        BidirectionalDijkstra dijkstrastoppingPoint = new BidirectionalDijkstra(graph);
        double distance = dijkstrastoppingPoint.computeShortestPath(0, 10);
        assertEquals(9.0, distance);

    }



}
